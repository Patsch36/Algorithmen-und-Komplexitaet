# Aufgaben

## Aufgabe 1- Verifikation

Führen Sie eine formale Verifikation des Programms auf Folie 02‐11 nach der Zusicherungsmethode durch und finden Sie heraus, was das Programm berechnet. Argumentieren Sie, warum das Programm terminiert.

## Aufgabe 2- Laufzeiten

### Aufgabenteil a

Gegeben sei die Java‐Klasse Laufzeiten.java. Was berechnen die einzelnen Methoden ܽa()  bis ݆j() in Abhängigkeit von n ( n >= 1)? Bestimmen Sie die asymptotische Laufzeit jeder der einzelnen Methoden als Funktion der Eingabegröße ݊n in O‐Notation. Begründen Sie Ihre Antworten.

### Aufgabenteil b

Bestimmen Sie die Laufzeiten der beiden Programme auf den Folien 02‐10 und 02‐11.

### Aufgabenteil c

Entwerfen Sie einen Algorithmus zur Suche von Duplikaten in einem Array und bestimmen Sie dessen Laufzeit‐Komplexität in O‐Notation.

## Aufgabe 3- Optimale Bereiche für Algorithmen

Die Algorithmen A, B und C lösen alle drei dasselbe Problem, allerdings haben sie unterschiedliche asymptotische Laufzeitkomplexitäten: 
$$
A: 1000\cdot n
$$

$$
B: 50\cdot n^2
$$

$$
C: 2^n
$$

### Aufgabeteil a

Berechnen Sie für welche Wertebereiche von n welcher Algorithmus am schnellsten ist. Stellen Sie die Ergebnisse auch grafisch (als Diagramm) dar und interpretieren Sie diese.

## Aufgabenteil b

Ein Rechner R1 benötigt 1 ms für die Abarbeitung eines Schritts. Berechnen Sie für jeden der drei Algorithmen A, B und C die maximale Problemgröße, die auf dem Rechner R1 in 1 s, in 1 min und in 1 h bearbeitet werden kann und stellen Sie die Ergebnisse in Form einer Tabelle dar.

### Aufgabenteil c

Die Fortschritte in der Technologie ermöglichen den Bau eines Rechners R2, der zehnmal so schnell ist wie R1. Erstellen Sie für den Rechner R2 die gleiche Tabelle wie vorher für den Rechner R1 und beurteilen Sie, um wie viel der neue Rechner R2 die maximal lösbare Problemgröße erhöht hat. Was leiten Sie daraus ab?

